---
title: 链表
date: 2022-07-03 21:24:04
permalink: /pages/2acd68/
categories:
  - 前端知识体系
  - 数据结构
tags:
  - 
---

## 介绍

链表是一种以列表存储值的数据结构，在列表中每一个值都被当作为一个节点，每一个节点都通过指针与列表的下一个值关联（若该节点是列表最后一个元素则下一个值为 null）。

有两种链表：单链表和双链表。两种链表的运作方式类似，但是在单链表中每一个节点有单指针指向下一个节点，在双链表中，每一个节点有双指针，一个指向下一个节点，一个指向上一个节点。

<div align="center">
  <img src="https://cdn.jsdelivr.net/gh/GuoLiBin6/images/tech-blog/single_link2.png" height="150">
</div>

<div align="center" style="margin-top:50px">
  <img src="https://cdn.jsdelivr.net/gh/GuoLiBin6/images/tech-blog/double_link2.png" height="150">
</div>

列表的第一个元素被当作头，列表的最后一个元素被当作尾。和数组一样，列表的长度由列表中的元素个数决定。

列表和数组主要不同包括：

 * 列表没有索引，列表中的每一个值仅“知道”其通过指针连接到的值。
 * 因为列表没有索引，所以我们不能随机访问列表中的元素。当我们想要访问一个值，必须通过从头到尾遍历整个列表的方法。
 * 没有索引的好处是添加或删除列表中任意部分比在数组中更高效。我们只需要重新分配指针指向的“相邻”值，但是在数组中，我们需要重新分配余下所有值的索引。
 * 
和其他所有数据结构一样，可以采用不同的方法来操作以链表存储的数据。通常会使用：push（在尾部添加）、pop（在尾部删除）、unshift（在头部添加）、shift（在头部删除）、get（获取）、set（设置）、remove（删除）和 reverse（反转）。

## 代码实现

### 单链表

```javascript
function Node(element){ 
    this.element = element; 
    this.next = null; 
} 
function List(){ 
    this.head = new Node('head'); 
    this.find = find; 
    this.insert = insert; 
    this.display = display; 
    this.findPrevious = findPrevious;
    this.remove = remove;
} 
function find(item){ 
    let currNode = this.head; 
    while(currNode.element!==item){ 
        currNode = currNode.next; 
    } 
    return currNode; 
} 
function insert(newElement, item){ 
    let newNode = new Node(newElement); 
    var currNode = this.find(item); 
    newNode.next = currNode.next; 
    currNode.next = newNode; 
} 
function display(){ 
    let currNode = this.head; 
    while(currNode.next!=null){ 
        console.log(currNode.next.element); 
        currNode = currNode.next; 
    } 
} 
function findPrevious (item){ 
    let currNode = this.head; 
    while(currNode.next!=null && currNode.next.element!=item){ 
        currNode = currNode.next; 
    } 
    return currNode; 
} 
function remove(item){ 
    let prevNode = this.findPrevious(item); 
    let currNode = this.find(item); 
    if(currNode.next!=null){ 
        prevNode.next = currNode.next; 
        currNode.next = null; 
    } 
}
```