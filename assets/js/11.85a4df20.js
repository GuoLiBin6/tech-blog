(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{488:function(t,_,a){"use strict";a.r(_);var v=a(20),r=Object(v.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程"}},[t._v("#")]),t._v(" 1. 进程")]),t._v(" "),a("p",[t._v("进程(process)是CPU资源分配的最小单位，是能拥有资源和独立内存的最小单位")]),t._v(" "),a("p",[t._v("程序运行时，系统会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中他的时候就会为它分配CPU时间，程序开始真正运行。")]),t._v(" "),a("h2",{attrs:{id:"_2-线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-线程"}},[t._v("#")]),t._v(" 2. 线程")]),t._v(" "),a("p",[t._v("线程(thread)是程序执行时的最小单位，是进程的一个执行流，CPU调度和分派的最小单位，一个进程可以有多个线程，线程之间共享进程的所有资源，每个进程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行，同样多线程也可以实现并发操作，每个请求分配一个线程来处理")]),t._v(" "),a("p",[t._v("当同一个进程内的两个线程需要使用同一个资源时，需要等另一个释放后才可使用")]),t._v(" "),a("p",[t._v("单线程和多线程的叫法，是指一个进程内的单和多")]),t._v(" "),a("h2",{attrs:{id:"_3-协程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-协程"}},[t._v("#")]),t._v(" 3. 协程")]),t._v(" "),a("p",[t._v("协程(coroutine)又称微线程，纤程。")]),t._v(" "),a("p",[t._v("协程不是进程，也不是线程，它就是一个函数，一个特殊的函数。可以在某个地方挂起，并且可以在挂起点重新恢复执行（保留其原始参数和局部变量）。所以协程和进程、线程相比，不是一个维度的概念。")]),t._v(" "),a("p",[t._v("一个线程内可以有多个协程，，但是一个进程内的多个协程是串行的。如果有多核CPU的话，多个进程或一个进程内的多个线程是可以并行的，但一个线程内的多个协程必须是串行的。")]),t._v(" "),a("h2",{attrs:{id:"_4-进程和线程的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-进程和线程的区别"}},[t._v("#")]),t._v(" 4. 进程和线程的区别")]),t._v(" "),a("p",[t._v("进程是资源分配的最小单位，线程是程序执行的最小单位、")]),t._v(" "),a("p",[t._v("进程有自己的独立地址空间，每启动一个进程，系统会为他分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是可以共享进程中的数据的，使用相同的地址空间，因此CPU切换一个进程的花费比线程小得多，同时创建一个线程的开销也比进程小很多。")]),t._v(" "),a("p",[t._v("线程之间通信更方便，统一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信方式(IPC)进行。不过如何处理好同步和互斥是编写多线程程序的难点。")]),t._v(" "),a("p",[t._v("多进程程序更健壮，多线程程序只要有一个线程死掉，整个程序也就死掉了，而一个进程死掉不会对另外一个进程造成影响，因为进程有自己独立的地址空间。")]),t._v(" "),a("h2",{attrs:{id:"_5-三者比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-三者比较"}},[t._v("#")]),t._v(" 5. 三者比较")]),t._v(" "),a("h3",{attrs:{id:"进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[t._v("#")]),t._v(" 进程")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("操作系统负责切换，变量隔离，自动切换运行上下文，切换内容保存于内核栈中，切换过程 用户态-内核态-用户态，切换效率低")])]),t._v(" "),a("li",[a("p",[t._v("切换内容包括页全局目录、内核栈、硬件上下文")])])]),t._v(" "),a("h3",{attrs:{id:"线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[t._v("#")]),t._v(" 线程")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("操作系统负责切换，变量隔离，自动切换运行上下文，切换内容保存于内核栈中，切换过程 用户态-内核态-用户态，切换效率中")])]),t._v(" "),a("li",[a("p",[t._v("切换内容包括内核栈、硬件上下文")])])]),t._v(" "),a("h3",{attrs:{id:"协程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协程"}},[t._v("#")]),t._v(" 协程")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("编程者/程序负责切换，变量不隔离，不自动切换运行上下文，切换内容存于自己的变量里，切换过程 用户态（没有陷入内核态）,切换效率高")])]),t._v(" "),a("li",[a("p",[t._v("切换内容包括硬件上下文")])])])])}),[],!1,null,null,null);_.default=r.exports}}]);